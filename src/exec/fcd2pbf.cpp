/**
 * Convert fcd XML trajectories to pbf format.
 * @author Yang Li 
 */
#include <fstream>
#include <iostream>
#include <sstream>
#include <map>
#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <string.h> 
#include <fcntl.h>
#include <unistd.h>
#include "../core/gps_trajectory.pb.h"
#include "../core/util.h"
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/io/zero_copy_stream_impl.h>
#include <GeographicLib/GeoCoords.hpp>
#include "../xmlparser/xmlParser.h"
 
using namespace std;
using namespace GeographicLib;


/**
 * datastructure to represent a point in the fcd trace
 */
struct VehiclePoint{
	int time;
	string id;
	string type;
	float lat;
	float lon;
	float x;
	float y;
	float angle;
	float speed;
	string lane;
	bool keep;
};

/** 
 * class FCDReader
 * read .fcd trajectory file generated by SUMO
 */
class FCDReader{
public:
	/** constructor **/
	FCDReader(const char * fname, int utm){
		minLat=MAX_D;
		minLon=MAX_D;
		maxLat=-MAX_D;
		maxLon=-MAX_D;
		utm_zone = utm;
		retrieveXMLMainNode(fname);
		parse();
		//	print();
	}
	/** add zero-mean guassian noise to trajectory data**/
	void addNoise(double stdev){
		default_random_engine generator;
		normal_distribution<double> dist(0,stdev);
		
		for (map<string,vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end(); it++){

			vector<VehiclePoint> &vpts = it->second;
			 

			for (unsigned i=0; i< vpts.size();++i){
				double xNew =  vpts[i].x + dist(generator),
					yNew =   vpts[i].y + dist(generator);
				if (xNew <= 1e6 && xNew >= 0)
					vpts[i].x = xNew;
				else
					continue;
				if (yNew <= 1e6 && yNew >= 0)
					vpts[i].y = yNew;
				else
					continue;

				Vector2d latlon = UTM2LatLon( 	vpts[i].x , vpts[i].y);
				vpts[i].lon = latlon[1];
				vpts[i].lat = latlon[0];
			}
		}
	}
	/** downsample trajectories **/
	void downSample(int level){

		for (map<string,vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end(); it++){ 

			vector<VehiclePoint> &vpts = it->second;
			int randomStart = random()%level;//start between 0, downsample-1
			for (unsigned i = 0; i < vpts.size(); ++i) {
			    if ((i+randomStart) % level !=0) {
			    	vpts[i].keep = false;
			    	 
			    }else{
			    	vpts[i].keep = true;
			    }
			}
		}
	}
	/**
	 * get integer flow number from car id string "flow.repeatNo"
	 * flow is based from 1
	 * @deprecated 
	 */
	int parseFlowId(const string &carId){
	
		size_t dot = carId.find(".");
		return stoi(carId.substr(0,dot));
	}

	/**
	 * write trajectories to pbf format
	 * @deprecated!
	 */
	void writePBF2(const char* pbfname, const char* lanename, int downsample){
		GOOGLE_PROTOBUF_VERIFY_VERSION;
		int fid = open(pbfname,O_WRONLY |O_CREAT |O_TRUNC );
		if (fid == -1){
			fprintf(stderr,"Error: cannot create protobuf file. \n");
			return;
		}
		ofstream lane_file(lanename,ofstream::out);
		google::protobuf::io::ZeroCopyOutputStream *raw_output 
			= new google::protobuf::io::FileOutputStream(fid);
		google::protobuf::io::CodedOutputStream *coded_output 
			= new google::protobuf::io::CodedOutputStream(raw_output);
		uint32_t num_trajectory = trajectories.size();

		coded_output->WriteLittleEndian32(num_trajectory);
		int globalId = 0;
		for (map<string,vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end(); it++){
			//int32_t global_id = (int32_t)string(it->first);

			lane_file <<  globalId << " " << it->first <<" ";

			vector<VehiclePoint> &vpts = it->second;
			GpsTraj new_traj;
			int randomStart = random()%downsample;//start between 0, downsample-1
			for (unsigned i = 0; i < vpts.size(); ++i) {
			    if ((i+randomStart) % downsample !=0) continue;
				TrajPoint* new_pt = new_traj.add_point(); 

				new_pt->set_car_id(i);			
				new_pt->set_speed(round(vpts[i].speed)*100);// speed unit is cm/sec
				new_pt->set_head(-round(vpts[i].angle) +180);//clockwise from north
				new_pt->set_lon((int32_t)round(vpts[i].lon*1e5));
				new_pt->set_lat((int32_t)round(vpts[i].lat*1e5));
				new_pt->set_x(vpts[i].x);
				new_pt->set_y(vpts[i].y);		 
				new_pt->set_timestamp((uint32_t)vpts[i].time);
				
				lane_file << vpts[i].lane<<" ";
			}
			string s;
			new_traj.SerializeToString(&s);
			coded_output->WriteLittleEndian32(s.size());
			coded_output->WriteString(s);

			lane_file <<"\n";
			globalId++;
		}
		delete coded_output;
		delete raw_output;
		close(fid);
		lane_file.close();
		cout <<"exported pbf file to " << pbfname  << endl;
		cout <<"exported lane file to " << lanename << endl;
	}
	/**
	 * write trajectory point - lane matching to txt file
	 */
	 void writeLane(const char* lanename){
		ofstream lane_file(lanename,ofstream::out);
		//uint32_t num_trajectory = trajectories.size();
		int globalId = 0;
		for (map<string,vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end(); it++){
			vector<VehiclePoint> &vpts = it->second;
			lane_file <<  globalId << " " << it->first <<" ";
			for (unsigned i = 0; i < vpts.size(); ++i) {
				if (vpts[i].keep){
					lane_file << vpts[i].lane<<" ";
				}
			}
			lane_file <<"\n";
			globalId++;
		}
		lane_file.close();
		cout <<"exported lane file to " << lanename << endl;
	 }
	/** 
	 * write trajectories to pbf format
	 */
	void writePBF(const char* pbfname ){
		GOOGLE_PROTOBUF_VERIFY_VERSION;
		int fid = open(pbfname,O_WRONLY |O_CREAT |O_TRUNC );
		if (fid == -1){
			fprintf(stderr,"Error: cannot create protobuf file. \n");
			return;
		} 
		google::protobuf::io::ZeroCopyOutputStream *raw_output 
			= new google::protobuf::io::FileOutputStream(fid);
		google::protobuf::io::CodedOutputStream *coded_output 
			= new google::protobuf::io::CodedOutputStream(raw_output);
		uint32_t num_trajectory = trajectories.size();

		coded_output->WriteLittleEndian32(num_trajectory);
	 
		for (map<string,vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end(); it++){ 
			vector<VehiclePoint> &vpts = it->second;
			GpsTraj new_traj;
 			for (unsigned i = 0; i < vpts.size(); ++i) {
 				if ( vpts[i].keep ){ 	   
					TrajPoint* new_pt = new_traj.add_point(); 
					new_pt->set_car_id(i);			
					new_pt->set_speed(round(vpts[i].speed *100));// speed unit is cm/sec
					new_pt->set_head(-round(vpts[i].angle) +180);//clockwise from north
					new_pt->set_lon((int32_t)round(vpts[i].lon*1e5));
					new_pt->set_lat((int32_t)round(vpts[i].lat*1e5));
					new_pt->set_x(vpts[i].x);
					new_pt->set_y(vpts[i].y);		 
					new_pt->set_timestamp((uint32_t)vpts[i].time); 
				}
			}
			string s;
			new_traj.SerializeToString(&s);
			coded_output->WriteLittleEndian32(s.size());
			coded_output->WriteString(s); 
		}
		delete coded_output;
		delete raw_output;
		close(fid); 
		cout <<"exported pbf file to " << pbfname  << endl; 
	}
	
	/** write bounding box to .bbox file **/
	void writeBoundingBox(const char* fname){
		ofstream file;
		file.open(fname,ios::out);
		if (file.is_open()){

			file << 1 << " " << minLat <<" " << minLon << " " 
				 << maxLat << " " << maxLon << endl;

			file.close();
		}
	}

protected:
    /** utm zone of the trajectories **/
    int utm_zone;
    
	/** map between trajectory id and trajectory data **/
	map<string,vector<VehiclePoint> > trajectories;

	/** xml main node in the .fcd file **/
	XMLNode xMainNode;

	/** top right and bottom left coordinates that
		represents the boundingbox of all trajectories **/
	double  minLat, minLon, maxLat, maxLon;

	/** open xml file and return the main node **/
	void retrieveXMLMainNode(const char* fname){
		string errorMsg;
		try {
			xMainNode=XMLNode::openFileHelper(fname, "fcd-export");
		}
		catch (int e) {
			cout <<"Error parsing XML main node" << endl;
			throw 1;
		}
	}
	/** insert a fcd trajectory point to trajectory map **/
	void accumulator(VehiclePoint v){ 
		trajectories[v.id].push_back(v);
	}
	/** parse the main node in fcd file **/
	void parse(){

		int nTimeSteps = xMainNode.nChildNode();
		for (int i=0; i<nTimeSteps;i++){

			XMLNode	xTimeStep = xMainNode.getChildNode("timestep",i);
			int t = atoi(xTimeStep.getAttribute("time"));
			int nVehicles = xTimeStep.nChildNode();

			for (int v=0; v<nVehicles;v++){

				XMLNode xVehicle = xTimeStep.getChildNode("vehicle",v);
				VehiclePoint vp;
				vp.time = t;
				vp.id =string( xVehicle.getAttribute("id"));
				vp.type = string(xVehicle.getAttribute("type"));
				vp.lane = string(xVehicle.getAttribute("lane"));
				vp.x = atof(xVehicle.getAttribute("x"));
				vp.y = atof(xVehicle.getAttribute("y"));
				vp.keep = true;
				if (vp.x>=0 && vp.y >=0){
					Vector2d latlon = this->UTM2LatLon(vp.x, vp.y);
					vp.lat = latlon[0];
					vp.lon = latlon[1];

					minLat = min(minLat,latlon[0]);
					minLon = min(minLon,latlon[1]);
					maxLat = max(maxLat,latlon[0]);
					maxLon = max(maxLon,latlon[1]);

					vp.angle = atof(xVehicle.getAttribute("angle"));
					vp.speed = atof(xVehicle.getAttribute("speed"));	
					accumulator(vp);
				}
			}
			/*if (i >= MAX_TIME_STEP){
				break;
				}*/
		}
		
	}
	/**
	 * print imported trajectory coordinates in the format of 
	 *	num_points x1 y1 x2 y2 ...
	 *	num_points x1 y1 x2 y2 ...
	 *	...
	 **/
	void print(){
		for (map<string, vector<VehiclePoint> >::iterator it=trajectories.begin();
			 it != trajectories.end();it++){
			vector<VehiclePoint> &vpts = it->second;
			cout << vpts.size()  ;
			for (unsigned i=0; i< vpts.size();i++){
				cout <<" "<<vpts[i].x << " "<< vpts[i].y ;
			}
			cout << endl;
		}
	}
	/** 
	 * convert utm (x,y) coordinates to latitude,longitude
	 * x: easting
	 * y: northing
	 */
	Vector2d UTM2LatLon(const double  &x, const double &y){
		bool north = true; // northern hemisphere
		GeoCoords c( utm_zone,north,x,y);
		
		Vector2d xy;
		xy[0] = c.Latitude();
		xy[1] = c.Longitude();
		return xy;
	}
};

void usage(){
    cout <<"Usage: fcd2pbf -i fcd_file -o output_basename [-n noise_std] [-u utm_zone] [-s downsample]\n";
	cout <<"  output will be written to <output_basename>.pbf and <output_basename>.bbox\n";
	cout <<"options:\n"
		 <<"  -n <float> noise_std   standard deviation of Guassian noise in meters. default is 0\n"
		 <<"  -u <int>   utm_zone    time zone of the fcd input file. default is 50 (Beijing)\n"
		 <<"  -s <int>   downsample  down-sample interval. default is 1 (no downample)\n";
		 
}

int main(int argc, char** argv){
	if (argc < 3){
		usage();
		return 0;
	}	
	char* output_name =  Util::GetCmdOption(argv,argv+argc,"-o");
	char* input_name = Util::GetCmdOption(argv,argv+argc,"-i");
	double noise_std = 0;
	if (Util::CmdOptionExists(argv,argv+argc,"-n")){
		noise_std = atof(Util::GetCmdOption(argv,argv+argc,"-n"));
	}
	int utm_zone = UTMZONE_DEFAULT;
	if (Util::CmdOptionExists(argv,argv+argc,"-u")){
		utm_zone = atof(Util::GetCmdOption(argv,argv+argc,"-u"));
	}
    int downsample_level = 1;
    if (Util::CmdOptionExists(argv, argv+argc,"-s")){
        downsample_level = atoi(Util::GetCmdOption(argv,argv+argc,"-s"));
    }

	cout <<"Parsing "<< input_name << "..."<< endl;
	cout <<"Nose stdev: " << noise_std<<" Sub-sample interval: " << downsample_level << endl;
	FCDReader reader(input_name,utm_zone);
	
	string pbf_fname = string(output_name) + ".pbf";
	string bbox_fname = string(output_name)+".bbox";
	string lane_fname = string(output_name)+".lane";
	if (noise_std >0)
		reader.addNoise(noise_std);
	if (downsample_level >1)
		reader.downSample(downsample_level);
	reader.writePBF(pbf_fname.c_str());
	reader.writeLane(lane_fname.c_str());
	reader.writeBoundingBox(bbox_fname.c_str());
}


